<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>packages.model_evaluation API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>packages.model_evaluation</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import tensorflow as tf
from tensorflow.keras import backend as K
import numpy as np


#-----------------------------------------------------------
# PROJET NEBULA
# Datascientest DS continu oct. 2020
# Librairie : MODEL_EVALUATION
#             Evaluation de modèle de segmentation d&#39;images
# Auteurs : Cathy Baynaud Samson
#           José Castro
#           Yann Bernery
#           Ludovic Changeon
#-----------------------------------------------------------

def iou_coef(y_true, y_pred, smooth=1):
    &#39;&#39;&#39;
        Metrique Intersection Over Union  
  
        Paramètre  
        ----------  
        y_true : cibles  
        y_pred : prédictions du modèle  
        smooth : parametre de robustesse aux outliers  
  
        Retour  
        ----------  
        Coefficient IOU  
    &#39;&#39;&#39;
    intersection = K.sum(K.abs(y_true * y_pred), axis=[1,2,3])
    union = K.sum(y_true,[1,2,3])+K.sum(y_pred,[1,2,3])-intersection
    iou = K.mean((intersection + smooth) / (union + smooth), axis=0)
    return iou

def tf_num(in1 : np.ndarray, in2 : np.ndarray):
    &#39;&#39;&#39;
        Fonction de support pour le calcul du coefficient de Dice  
  
        Paramètre  
        ----------  
        in1, in2 : np.ndarray ou tf.Tensor, les deux ensembles à comparer    
  
        Retour  
        ----------  
        tf.Tensor  
    &#39;&#39;&#39;
    # Conversions pour éviter les incompatibilités
    a = K.cast(in1, tf.float32)
    b = K.cast(in2, tf.float32)
    # Retour de la fonction
    return K.log(1. + a * b) / K.log(2.)

def dice(in1 : np.ndarray, in2 : np.ndarray, classWeights : np.ndarray= np.ones(4), smooth : tf.float32 = K.epsilon()):
    &#39;&#39;&#39;
        Calcul du coefficient de Dice de deux ensembles  
        Paramètre  
        ----------  
        in1, in2 : np.ndarray ou tf.Tensor de rangs 1, 2, 3 ou 4, valeurs entre 0 et 1  
        classWeights : np.ndarray pondération optionnelle des 4 classes d&#39;apprentissage  
            [1., 1., 1., 1.] par défaut  
            La pondération n&#39;est utilisée que pour les tenseurs de rangs 3 et 4.  
            La pndération implique : in1.shape = (...,4) et in2.shape = (...,4)  
        smooth : parametre de robustesse aux outliers  
  
        Retour  
        ----------  
        m : coefficient de Dice (https://fr.wikipedia.org/wiki/Indice_de_S%C3%B8rensen-Dice)  
    &#39;&#39;&#39;
    # Conversions pour éviter les incompatibilités
    a = K.cast(in1, tf.float32)
    b = K.cast(in2, tf.float32)
    w = K.cast(classWeights, tf.float32)
    # Calculs de la métrique de Dice pour rang de tenseurs entre 1 et 4
    if K.ndim(a) == 4:
        num = K.mean(K.sum(tf_num(a,b),(2,1)),0)
        denom = K.mean(K.sum(a,(2,1)) + K.sum(b,(2,1)),0)
        m= (2.*K.sum(num * w) + smooth) / \
        (K.sum(denom * w) + smooth)
    elif K.ndim(a) == 3:
        num = K.sum(tf_num(a,b),(1,0))
        denom = K.sum(a,(1,0)) + K.sum(b,(1,0))
        m= (2.*K.sum(num * w) + smooth) / \
        (K.sum(denom * w) + smooth)
    elif K.ndim(a) == 2:
        m= (2.*K.sum(tf_num(a,b),(1,0)) + smooth) / \
        (K.sum(a,(1,0)) + K.sum(b,(1,0)) + smooth)
    else :
        m= (2.*K.sum(tf_num(a,b),(0)) + smooth) / \
        (K.sum(a,(0)) + K.sum(b,(0)) + smooth)
    return m

class diceMetric(tf.keras.metrics.Metric):
    &#39;&#39;&#39;
        Classe utilisant le coefficient de Dice pour calculer la métrique d&#39;apprentissage  
        Utilisation :  
            metrics = diceMetric(name = &#39;DiceM&#39;, classWeights = np.ones(4))  
            metrics.update_state(y_true, y_pred)  
            metrics.result()  
        Paramètre  
        ----------  
        y_true : cibles  
        y_pred : prédictions du modèle  
        name : nom sous lequel apparaîtra la métrique  
        classWeights : pondération des 4 classes de segmentation  
  
        Retour  
        ----------  
        Coefficient de Dice (https://fr.wikipedia.org/wiki/Indice_de_S%C3%B8rensen-Dice)  
    &#39;&#39;&#39;
    def __init__(self, name:str = &#39;diceM&#39;, classWeights : np.ndarray = np.ones(4), **kwargs):
        super().__init__(name = name , **kwargs)
        self.diceM = 0
        self.classWeights = tf.cast(classWeights,&#39;float32&#39;)
    def update_state(self, y_true:tf.Tensor, y_pred:tf.Tensor, sample_weight=None):
        self.diceM = dice(y_true, y_pred, self.classWeights)
    def result(self):
        return self.diceM
    def reset_state(self):
        self.diceM=0.

class diceLoss(tf.keras.losses.Loss):
    &#39;&#39;&#39;
        Classe utilisant le coefficient de Dice pour calculer la perte d&#39;apprentissage  
        Utilisation :  
            loss = diceLoss(name = &#39;DiceL&#39;, classWeights = np.ones(4))  
            loss(y_true, y_pred)  
        Paramètre  
        ----------  
        y_true : cibles  
        y_pred : prédictions du modèle  
        name : nom sous lequel apparaîtra la perte  
        classWeights : pondération des 4 classes de segmentation  
  
        Retour  
        ----------  
        loss = 1. - m (m : Coefficient de Dice (https://fr.wikipedia.org/wiki/Indice_de_S%C3%B8rensen-Dice))  
    &#39;&#39;&#39;
    def __init__(self, name: str =&#39;diceL&#39;, classWeights : np.ndarray = np.ones(4), **kwargs):
        super().__init__(name = name, **kwargs)
        self.classWeights = tf.cast(classWeights,&#39;float32&#39;)
    def call(self, y_true : tf.Tensor, y_pred : tf.Tensor):
        perte = 1. - dice(y_true, y_pred, self.classWeights)
        return perte</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="packages.model_evaluation.dice"><code class="name flex">
<span>def <span class="ident">dice</span></span>(<span>in1: numpy.ndarray, in2: numpy.ndarray, classWeights: numpy.ndarray = array([1., 1., 1., 1.]), smooth: tf.float32 = 1e-07)</span>
</code></dt>
<dd>
<div class="desc"><p>Calcul du coefficient de Dice de deux ensembles<br>
Paramètre
</p>
<hr>
<p>in1, in2 : np.ndarray ou tf.Tensor de rangs 1, 2, 3 ou 4, valeurs entre 0 et 1<br>
classWeights : np.ndarray pondération optionnelle des 4 classes d'apprentissage<br>
[1., 1., 1., 1.] par défaut<br>
La pondération n'est utilisée que pour les tenseurs de rangs 3 et 4.<br>
La pndération implique : in1.shape = (&hellip;,4) et in2.shape = (&hellip;,4)<br>
smooth : parametre de robustesse aux outliers
</p>
<h2 id="retour">Retour</h2>
<p>m : coefficient de Dice (<a href="https://fr.wikipedia.org/wiki/Indice_de_S%C3%B8rensen-Dice">https://fr.wikipedia.org/wiki/Indice_de_S%C3%B8rensen-Dice</a>)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dice(in1 : np.ndarray, in2 : np.ndarray, classWeights : np.ndarray= np.ones(4), smooth : tf.float32 = K.epsilon()):
    &#39;&#39;&#39;
        Calcul du coefficient de Dice de deux ensembles  
        Paramètre  
        ----------  
        in1, in2 : np.ndarray ou tf.Tensor de rangs 1, 2, 3 ou 4, valeurs entre 0 et 1  
        classWeights : np.ndarray pondération optionnelle des 4 classes d&#39;apprentissage  
            [1., 1., 1., 1.] par défaut  
            La pondération n&#39;est utilisée que pour les tenseurs de rangs 3 et 4.  
            La pndération implique : in1.shape = (...,4) et in2.shape = (...,4)  
        smooth : parametre de robustesse aux outliers  
  
        Retour  
        ----------  
        m : coefficient de Dice (https://fr.wikipedia.org/wiki/Indice_de_S%C3%B8rensen-Dice)  
    &#39;&#39;&#39;
    # Conversions pour éviter les incompatibilités
    a = K.cast(in1, tf.float32)
    b = K.cast(in2, tf.float32)
    w = K.cast(classWeights, tf.float32)
    # Calculs de la métrique de Dice pour rang de tenseurs entre 1 et 4
    if K.ndim(a) == 4:
        num = K.mean(K.sum(tf_num(a,b),(2,1)),0)
        denom = K.mean(K.sum(a,(2,1)) + K.sum(b,(2,1)),0)
        m= (2.*K.sum(num * w) + smooth) / \
        (K.sum(denom * w) + smooth)
    elif K.ndim(a) == 3:
        num = K.sum(tf_num(a,b),(1,0))
        denom = K.sum(a,(1,0)) + K.sum(b,(1,0))
        m= (2.*K.sum(num * w) + smooth) / \
        (K.sum(denom * w) + smooth)
    elif K.ndim(a) == 2:
        m= (2.*K.sum(tf_num(a,b),(1,0)) + smooth) / \
        (K.sum(a,(1,0)) + K.sum(b,(1,0)) + smooth)
    else :
        m= (2.*K.sum(tf_num(a,b),(0)) + smooth) / \
        (K.sum(a,(0)) + K.sum(b,(0)) + smooth)
    return m</code></pre>
</details>
</dd>
<dt id="packages.model_evaluation.iou_coef"><code class="name flex">
<span>def <span class="ident">iou_coef</span></span>(<span>y_true, y_pred, smooth=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Metrique Intersection Over Union
</p>
<h2 id="parametre">Paramètre</h2>
<p>y_true : cibles<br>
y_pred : prédictions du modèle<br>
smooth : parametre de robustesse aux outliers
</p>
<h2 id="retour">Retour</h2>
<p>Coefficient IOU</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iou_coef(y_true, y_pred, smooth=1):
    &#39;&#39;&#39;
        Metrique Intersection Over Union  
  
        Paramètre  
        ----------  
        y_true : cibles  
        y_pred : prédictions du modèle  
        smooth : parametre de robustesse aux outliers  
  
        Retour  
        ----------  
        Coefficient IOU  
    &#39;&#39;&#39;
    intersection = K.sum(K.abs(y_true * y_pred), axis=[1,2,3])
    union = K.sum(y_true,[1,2,3])+K.sum(y_pred,[1,2,3])-intersection
    iou = K.mean((intersection + smooth) / (union + smooth), axis=0)
    return iou</code></pre>
</details>
</dd>
<dt id="packages.model_evaluation.tf_num"><code class="name flex">
<span>def <span class="ident">tf_num</span></span>(<span>in1: numpy.ndarray, in2: numpy.ndarray)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction de support pour le calcul du coefficient de Dice
</p>
<h2 id="parametre">Paramètre</h2>
<p>in1, in2 : np.ndarray ou tf.Tensor, les deux ensembles à comparer
</p>
<h2 id="retour">Retour</h2>
<p>tf.Tensor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tf_num(in1 : np.ndarray, in2 : np.ndarray):
    &#39;&#39;&#39;
        Fonction de support pour le calcul du coefficient de Dice  
  
        Paramètre  
        ----------  
        in1, in2 : np.ndarray ou tf.Tensor, les deux ensembles à comparer    
  
        Retour  
        ----------  
        tf.Tensor  
    &#39;&#39;&#39;
    # Conversions pour éviter les incompatibilités
    a = K.cast(in1, tf.float32)
    b = K.cast(in2, tf.float32)
    # Retour de la fonction
    return K.log(1. + a * b) / K.log(2.)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="packages.model_evaluation.diceLoss"><code class="flex name class">
<span>class <span class="ident">diceLoss</span></span>
<span>(</span><span>name: str = 'diceL', classWeights: numpy.ndarray = array([1., 1., 1., 1.]), **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Classe utilisant le coefficient de Dice pour calculer la perte d'apprentissage<br>
Utilisation :<br>
loss = diceLoss(name = 'DiceL', classWeights = np.ones(4))<br>
loss(y_true, y_pred)<br>
Paramètre
</p>
<hr>
<p>y_true : cibles<br>
y_pred : prédictions du modèle<br>
name : nom sous lequel apparaîtra la perte<br>
classWeights : pondération des 4 classes de segmentation
</p>
<h2 id="retour">Retour</h2>
<p>loss = 1. - m (m : Coefficient de Dice (<a href="https://fr.wikipedia.org/wiki/Indice_de_S%C3%B8rensen-Dice">https://fr.wikipedia.org/wiki/Indice_de_S%C3%B8rensen-Dice</a>))
</p>
<p>Initializes <code>Loss</code> class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>reduction</code></strong></dt>
<dd>(Optional) Type of <code>tf.keras.losses.Reduction</code> to apply to
loss. Default value is <code>AUTO</code>. <code>AUTO</code> indicates that the reduction
option will be determined by the usage context. For almost all cases
this defaults to <code>SUM_OVER_BATCH_SIZE</code>. When used with
<code>tf.distribute.Strategy</code>, outside of built-in training loops such as
<code>tf.keras</code> <code>compile</code> and <code>fit</code>, using <code>AUTO</code> or <code>SUM_OVER_BATCH_SIZE</code>
will raise an error. Please see this custom training <a href="https://www.tensorflow.org/tutorials/distribute/custom_training">tutorial</a> for
more details.</dd>
<dt><strong><code>name</code></strong></dt>
<dd>Optional name for the op.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class diceLoss(tf.keras.losses.Loss):
    &#39;&#39;&#39;
        Classe utilisant le coefficient de Dice pour calculer la perte d&#39;apprentissage  
        Utilisation :  
            loss = diceLoss(name = &#39;DiceL&#39;, classWeights = np.ones(4))  
            loss(y_true, y_pred)  
        Paramètre  
        ----------  
        y_true : cibles  
        y_pred : prédictions du modèle  
        name : nom sous lequel apparaîtra la perte  
        classWeights : pondération des 4 classes de segmentation  
  
        Retour  
        ----------  
        loss = 1. - m (m : Coefficient de Dice (https://fr.wikipedia.org/wiki/Indice_de_S%C3%B8rensen-Dice))  
    &#39;&#39;&#39;
    def __init__(self, name: str =&#39;diceL&#39;, classWeights : np.ndarray = np.ones(4), **kwargs):
        super().__init__(name = name, **kwargs)
        self.classWeights = tf.cast(classWeights,&#39;float32&#39;)
    def call(self, y_true : tf.Tensor, y_pred : tf.Tensor):
        perte = 1. - dice(y_true, y_pred, self.classWeights)
        return perte</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tensorflow.python.keras.losses.Loss</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="packages.model_evaluation.diceLoss.call"><code class="name flex">
<span>def <span class="ident">call</span></span>(<span>self, y_true: tensorflow.python.framework.ops.Tensor, y_pred: tensorflow.python.framework.ops.Tensor)</span>
</code></dt>
<dd>
<div class="desc"><p>Invokes the <code>Loss</code> instance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>y_true</code></strong></dt>
<dd>Ground truth values. shape = <code>[batch_size, d0, .. dN]</code>, except
sparse loss functions such as sparse categorical crossentropy where
shape = <code>[batch_size, d0, .. dN-1]</code></dd>
<dt><strong><code>y_pred</code></strong></dt>
<dd>The predicted values. shape = <code>[batch_size, d0, .. dN]</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Loss values with the shape <code>[batch_size, d0, .. dN-1]</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def call(self, y_true : tf.Tensor, y_pred : tf.Tensor):
    perte = 1. - dice(y_true, y_pred, self.classWeights)
    return perte</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="packages.model_evaluation.diceMetric"><code class="flex name class">
<span>class <span class="ident">diceMetric</span></span>
<span>(</span><span>name: str = 'diceM', classWeights: numpy.ndarray = array([1., 1., 1., 1.]), **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Classe utilisant le coefficient de Dice pour calculer la métrique d'apprentissage<br>
Utilisation :<br>
metrics = diceMetric(name = 'DiceM', classWeights = np.ones(4))<br>
metrics.update_state(y_true, y_pred)<br>
metrics.result()<br>
Paramètre
</p>
<hr>
<p>y_true : cibles<br>
y_pred : prédictions du modèle<br>
name : nom sous lequel apparaîtra la métrique<br>
classWeights : pondération des 4 classes de segmentation
</p>
<h2 id="retour">Retour</h2>
<p>Coefficient de Dice (<a href="https://fr.wikipedia.org/wiki/Indice_de_S%C3%B8rensen-Dice">https://fr.wikipedia.org/wiki/Indice_de_S%C3%B8rensen-Dice</a>)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class diceMetric(tf.keras.metrics.Metric):
    &#39;&#39;&#39;
        Classe utilisant le coefficient de Dice pour calculer la métrique d&#39;apprentissage  
        Utilisation :  
            metrics = diceMetric(name = &#39;DiceM&#39;, classWeights = np.ones(4))  
            metrics.update_state(y_true, y_pred)  
            metrics.result()  
        Paramètre  
        ----------  
        y_true : cibles  
        y_pred : prédictions du modèle  
        name : nom sous lequel apparaîtra la métrique  
        classWeights : pondération des 4 classes de segmentation  
  
        Retour  
        ----------  
        Coefficient de Dice (https://fr.wikipedia.org/wiki/Indice_de_S%C3%B8rensen-Dice)  
    &#39;&#39;&#39;
    def __init__(self, name:str = &#39;diceM&#39;, classWeights : np.ndarray = np.ones(4), **kwargs):
        super().__init__(name = name , **kwargs)
        self.diceM = 0
        self.classWeights = tf.cast(classWeights,&#39;float32&#39;)
    def update_state(self, y_true:tf.Tensor, y_pred:tf.Tensor, sample_weight=None):
        self.diceM = dice(y_true, y_pred, self.classWeights)
    def result(self):
        return self.diceM
    def reset_state(self):
        self.diceM=0.</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tensorflow.python.keras.metrics.Metric</li>
<li>tensorflow.python.keras.engine.base_layer.Layer</li>
<li>tensorflow.python.module.module.Module</li>
<li>tensorflow.python.training.tracking.tracking.AutoTrackable</li>
<li>tensorflow.python.training.tracking.base.Trackable</li>
<li>tensorflow.python.keras.utils.version_utils.LayerVersionSelector</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="packages.model_evaluation.diceMetric.reset_state"><code class="name flex">
<span>def <span class="ident">reset_state</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Resets all of the metric state variables.</p>
<p>This function is called between epochs/steps,
when a metric is evaluated during training.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_state(self):
    self.diceM=0.</code></pre>
</details>
</dd>
<dt id="packages.model_evaluation.diceMetric.result"><code class="name flex">
<span>def <span class="ident">result</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes and returns the metric value tensor.</p>
<p>Result computation is an idempotent operation that simply calculates the
metric value using the state variables.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def result(self):
    return self.diceM</code></pre>
</details>
</dd>
<dt id="packages.model_evaluation.diceMetric.update_state"><code class="name flex">
<span>def <span class="ident">update_state</span></span>(<span>self, y_true: tensorflow.python.framework.ops.Tensor, y_pred: tensorflow.python.framework.ops.Tensor, sample_weight=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Accumulates statistics for the metric.</p>
<p>Note: This function is executed as a graph function in graph mode.
This means:
a) Operations on the same resource are executed in textual order.
This should make it easier to do things like add the updated
value of a variable to another, for example.
b) You don't need to worry about collecting the update ops to execute.
All update ops added to the graph by this function will be executed.
As a result, code should generally work the same way with graph or
eager execution.</p>
<h2 id="args">Args</h2>
<dl>
<dt>*args:</dt>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>A mini-batch of inputs to the Metric.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_state(self, y_true:tf.Tensor, y_pred:tf.Tensor, sample_weight=None):
    self.diceM = dice(y_true, y_pred, self.classWeights)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="packages" href="index.html">packages</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="packages.model_evaluation.dice" href="#packages.model_evaluation.dice">dice</a></code></li>
<li><code><a title="packages.model_evaluation.iou_coef" href="#packages.model_evaluation.iou_coef">iou_coef</a></code></li>
<li><code><a title="packages.model_evaluation.tf_num" href="#packages.model_evaluation.tf_num">tf_num</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="packages.model_evaluation.diceLoss" href="#packages.model_evaluation.diceLoss">diceLoss</a></code></h4>
<ul class="">
<li><code><a title="packages.model_evaluation.diceLoss.call" href="#packages.model_evaluation.diceLoss.call">call</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="packages.model_evaluation.diceMetric" href="#packages.model_evaluation.diceMetric">diceMetric</a></code></h4>
<ul class="">
<li><code><a title="packages.model_evaluation.diceMetric.reset_state" href="#packages.model_evaluation.diceMetric.reset_state">reset_state</a></code></li>
<li><code><a title="packages.model_evaluation.diceMetric.result" href="#packages.model_evaluation.diceMetric.result">result</a></code></li>
<li><code><a title="packages.model_evaluation.diceMetric.update_state" href="#packages.model_evaluation.diceMetric.update_state">update_state</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>