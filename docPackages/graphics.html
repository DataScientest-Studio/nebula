<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>packages.graphics API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>packages.graphics</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import numpy as np
import os
import cv2
import PIL
from PIL import Image
from skimage.segmentation import mark_boundaries
from skimage.measure import label, regionprops


#-----------------------------------------------------------
# PROJET NEBULA
# Datascientest DS continu oct. 2020
# Librairie : GRAPHICS
#             Traitement des images et masques RLE
# Auteurs : Cathy Baynaud Samson
#           José Castro
#           Yann Bernery
#           Ludovic Changeon
#-----------------------------------------------------------

def np_transposition(image: np.ndarray, input_shape: tuple) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Transposition d&#39;un np array afin d&#39;inverser les dimensions (hauteur, largeur)   
    vers (largeur, hauteur).  
    Si les dimensions initiales sont différentes de (height,width), un redimensionnement est effectué.  
  
     Paramètre  
     ----------  
     image : np array a transposer   
     input_shape : dimensions de l&#39;image cible  
  
     Retour  
     ----------  
     np.array : image transposee  
    &#34;&#34;&#34;

    height, width = input_shape
    return cv2.resize(image, (width, height))

    
def rleToMask(rle: str, shape: tuple  =(1400, 2100)) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Conversion d&#39;un codage RLE en masque  
  
     Paramètre  
     ----------  
     rle   : encodage RLE a convertir   
     shape : format du masque  
  
     Retour  
     ----------  
     np.array : masque  
    &#34;&#34;&#34;

    width, height = shape[:2]
    
    mask= np.zeros( width*height ).astype(np.uint8)
    
    array = np.asarray([int(x) for x in rle.split()])
    starts = array[0::2]
    lengths = array[1::2]

    current_position = 0
    for index, start in enumerate(starts):
        mask[int(start):int(start+lengths[index])] = 1
        current_position += lengths[index]
        
    return mask.reshape(height, width).T


def maskToRle(mask: np.ndarray) -&gt; str:
    &#34;&#34;&#34;
    Conversion d&#39;un masque en encodage RLE  
    La presence d&#39;un pixel dans le masque se materialise par la valeur 1,  
    autrement la valeur reste a 0  
  
     Paramètre  
     ----------  
     mask : masque a encoder  
  
     Retour  
     ----------  
     str : encodage RLE  
    &#34;&#34;&#34;

    valeur_pixels = mask.T.flatten()
    valeur_pixels = np.concatenate([[0], valeur_pixels, [0]])
    segment_rle = np.where(valeur_pixels[1:] != valeur_pixels[:-1])[0] + 1
    segment_rle[1::2] -= segment_rle[::2]
    return &#39; &#39;.join(str(x) for x in segment_rle)


def list_rleToMask(rle_list:[str], input_shape:tuple, reshape: tuple = None)  -&gt; np.ndarray :
    &#34;&#34;&#34;
    Conversion d&#39;une liste d&#39;encodage RLE en liste de masques  
  
     Paramètre  
     ----------  
     rle_list    : liste des encodage RLE a convertir  
     input_shape : taille d&#39;origine des masques  
     reshape     : facultatif, taille desiree en sortie  
  
     Retour  
     ----------  
      np.ndarray : liste des masques  
    &#34;&#34;&#34;  

    nb_rle = len(rle_list)
    if reshape is None:
        mask_list = np.zeros((*input_shape, nb_rle))
    else:
        mask_list = np.zeros((*reshape, nb_rle))
    
    for i, rle in enumerate(rle_list):
        if type(rle) is str:
            if reshape is None:
                mask_list[:, :, i] = rleToMask(rle, input_shape)
            else:
                mask = rleToMask(rle, input_shape)
                reshaped_mask = np_transposition(mask, reshape)
                mask_list[:, :, i] = reshaped_mask
    
    return mask_list
    

def list_maskToRle(mask_list:np.ndarray , reshape:tuple = None) -&gt; [str]:
    &#34;&#34;&#34;
    Encodage d&#39;une liste de masques en codes RLE  
  
     Paramètre  
     ----------  
     mask_list   : liste des masques a encoder  
     reshape     : facultatif, taille desiree des masques avant encodage  
  
     Retour  
     ----------  
      liste de str : liste des codes RLE  
    &#34;&#34;&#34; 

    width, height, nb_mask = mask_list.shape
    
    rle_list = []
    
    for i in range(nb_mask):
        mask = mask_list[:, :, i]
        
        if reshape:
            mask = mask.astype(np.float32)
            mask = np_transposition(mask, reshape).astype(np.int64)
        
        rle = maskToRle(mask)
        rle_list.append(rle)
        
    return rle_list
    
        
def surfaceFromRle(rle: str) -&gt; int:
    &#34;&#34;&#34;Determination de la surface (en pixels) converte par le masque correspondage 
       a l&#39;encodage RLE specifie en parametre  
  
     Paramètre  
     ----------  
     rle : encodage RLE a analyser  
  
     Retour  
     ----------  
     int : surface couverte en pixels  
    &#34;&#34;&#34;  
    
    
    #Initialisation de la surface
    surface = 0
    
    rleNumbers = [int(numstring) for numstring in rle.split(&#39; &#39;)]
    rlePairs = np.array(rleNumbers).reshape(-1,2)

    #Pour chaque pairs, on incrémente la surface par la nouvelle
    #longueur de chaine
    for index,length in rlePairs:
        surface += length
    
    return surface


def imshowSuperimposed(nomImage: str, rle: str = &#39;&#39;, classe: str = &#39;Fish&#39;, repImage: str = &#39;.&#39;, rleSize: tuple = (1400,2100))-&gt; dict:
    &#34;&#34;&#34;Superposition d&#39;une image RGB et de sa segmentation RLE, colorée par classe  
      
     Paramètre  
     ----------  
     nomImage : nom de l&#39;image à afficher  
     repImage : nom du répertoire vers les images (&#39;.&#39; par défaut)  
     rle : encodage RLE du masque à superposer  
     classe : nom de la classe du masque, parmi {&#39;Fish&#39;, &#39;Flower&#39;, &#39;Gravel&#39;, &#39;Sugar&#39;}  
     rleSize : taille du masque RLE en pixels  
       
     Retour  
     ----------  
     dict : {&#39;Superimposed&#39;: image ndarray (&#39;uint8&#39;) RGB avec sa segmentation,  
             &#39;Label&#39;: nom de l&#39;image / classe de segmentation,  
             &#39;Image&#39;: image originale ndarray (&#39;uint8&#39;) RGB,  
             &#39;Segmentation&#39;: image ndarray (&#39;uint8&#39;) RGB du masque de segmentation}  
    &#34;&#34;&#34;
    
    #Initialisation du dictionnaire des couleurs (sur base de RGB)
    couleurs = {&#39;Fish&#39;:  2, #blue
                &#39;Flower&#39;:0, #red
                &#39;Gravel&#39;:1, #green
                &#39;Sugar&#39;:slice(0,2,1)} #yellow

    #Chargement de l&#39;image demandée
    path = os.path.join(repImage, nomImage)
    img = Image.open(path)

    #Si la taille de l&#39;image est différente de celle du masque,
    #on met l&#39;image à l&#39;échelle du masque
    img = img.resize(size = rleSize[::-1], resample = Image.BILINEAR ).convert(&#39;RGB&#39;)

    #Chargement du masque à partir du codage RLE
    mask = np.zeros(rleSize)
    if rle != &#39;&#39; : mask = rleToMask(rle, shape = rleSize)

    #Coloration du masque
    couleur = couleurs[classe]                            # on récupère la couleur de la classe
    imgMask = np.zeros(rleSize+(3,))                      # initialisation du masque pour 3 channels
    imgMask[:,:,couleur] =  np.dstack([mask,mask,mask])[:,:,couleur] * 255  # modification du masque vers trois channels
    imgMask = Image.fromarray(imgMask.astype(&#39;uint8&#39;))

    #Superposition de l&#39;image et de son masque
    #Images converties en numpy.array pour utiliser la fonction addWeighted d&#39;OpenCV
    #Cette fonction est la plus pratique pour conserver l&#39;alpha de l&#39;image originale à 1
    
    imgOverlay = cv2.addWeighted(np.array(img), 1, np.array(imgMask), 0.5, 0.0)
    
    #Si le code rle fourni était vide, on efface la classe par défaut
    if rle == &#39;&#39;: classe = &#39;&#39;
    
    dico = {&#39;Superimposed&#39; : imgOverlay,
            &#39;Label&#39; : nomImage + &#39; / &#39; + classe,
            &#39;Image&#39; : np.array(img),
            &#39;Segmentation&#39;: np.array(imgMask)}
    
    return dico


def trace_boundingBox(image : np.ndarray,
                      mask : np.ndarray,
                      color : tuple = (0,0,255),
                      width : int = 10):
    &#34;&#34;&#34;
    Draw a bounding box on image

     Parameter
     ----------
     image : image on which we want to draw the box 
     mask  : mask to process
     color : color we want to use to draw the box edges
     width : box edges&#39;s width

     Return
     ----------
     None
    &#34;&#34;&#34;
    
    lbl = label(mask)
    props = regionprops(lbl)
    for prop in props:
        coin1 = (prop.bbox[3], prop.bbox[2])
        coin2 = (prop.bbox[1], prop.bbox[0])
        cv2.rectangle(image, coin2, coin1, color, width)
    return None

        
def maskInColor(image : np.ndarray, 
                mask : np.ndarray, 
                color : tuple = (0,0,255), 
                alpha : float=0.2) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Superposition d&#39;un masque sur une image  
  
     Parameter  
     ----------  
     image : image sur laqelle le masque doit etre superpose  
     mask  : masque a superposer  
     color : colour du masque  
     alpha : coefficient d&#39;opacite  
  
     Return  
     ----------  
     np.array : image resultant de la superposition  
    &#34;&#34;&#34;
    
    image = np.array(image)
    H,W,C = image.shape
    mask    = mask.reshape(H,W,1)
    overlay = image.astype(np.float32)
    overlay =  255-(255-overlay)*(1-mask*alpha*color/255 )
    overlay = np.clip(overlay,0,255)
    overlay = overlay.astype(np.uint8)
    return overlay


def cloudInColor(image : np.ndarray, 
                 mask : np.ndarray, 
                 color : tuple = (0,0,255),
                 alpha : float = 0.7, 
                 threshold : int = 90) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Coloration des pixels d&#39;une image sur la base d&#39;un seuil  
  
     Parameter  
     ----------  
     image : image a colorer  
     mask  : masque de traitement  
     color : couleur a appliquer  
     alpha : coefficient d&#39;opacite  
     threshold : seuil  
       
     Return  
     ----------  
     np.array : image coloree  
    &#34;&#34;&#34;
        
    imZone = cv2.bitwise_and(image, image, mask=mask)
    image_gray = cv2.cvtColor(imZone, cv2.COLOR_RGB2GRAY)
    (thresh, blackAndWhiteImage) = cv2.threshold(image_gray, 
                                                 threshold, 
                                                 255, 
                                                 cv2.THRESH_BINARY)
    inlay = maskInColor(image, blackAndWhiteImage, color=color, alpha=alpha)
    return inlay</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="packages.graphics.cloudInColor"><code class="name flex">
<span>def <span class="ident">cloudInColor</span></span>(<span>image: numpy.ndarray, mask: numpy.ndarray, color: tuple = (0, 0, 255), alpha: float = 0.7, threshold: int = 90) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Coloration des pixels d'une image sur la base d'un seuil
</p>
<p>Parameter
</p>
<hr>
<p>image : image a colorer<br>
mask
: masque de traitement<br>
color : couleur a appliquer<br>
alpha : coefficient d'opacite<br>
threshold : seuil
</p>
<p>Return
</p>
<hr>
<p>np.array : image coloree</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cloudInColor(image : np.ndarray, 
                 mask : np.ndarray, 
                 color : tuple = (0,0,255),
                 alpha : float = 0.7, 
                 threshold : int = 90) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Coloration des pixels d&#39;une image sur la base d&#39;un seuil  
  
     Parameter  
     ----------  
     image : image a colorer  
     mask  : masque de traitement  
     color : couleur a appliquer  
     alpha : coefficient d&#39;opacite  
     threshold : seuil  
       
     Return  
     ----------  
     np.array : image coloree  
    &#34;&#34;&#34;
        
    imZone = cv2.bitwise_and(image, image, mask=mask)
    image_gray = cv2.cvtColor(imZone, cv2.COLOR_RGB2GRAY)
    (thresh, blackAndWhiteImage) = cv2.threshold(image_gray, 
                                                 threshold, 
                                                 255, 
                                                 cv2.THRESH_BINARY)
    inlay = maskInColor(image, blackAndWhiteImage, color=color, alpha=alpha)
    return inlay</code></pre>
</details>
</dd>
<dt id="packages.graphics.imshowSuperimposed"><code class="name flex">
<span>def <span class="ident">imshowSuperimposed</span></span>(<span>nomImage: str, rle: str = '', classe: str = 'Fish', repImage: str = '.', rleSize: tuple = (1400, 2100)) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Superposition d'une image RGB et de sa segmentation RLE, colorée par classe
</p>
<h2 id="parametre">Paramètre</h2>
<p>nomImage : nom de l'image à afficher<br>
repImage : nom du répertoire vers les images ('.' par défaut)<br>
rle : encodage RLE du masque à superposer<br>
classe : nom de la classe du masque, parmi {'Fish', 'Flower', 'Gravel', 'Sugar'}<br>
rleSize : taille du masque RLE en pixels
</p>
<h2 id="retour">Retour</h2>
<p>dict : {'Superimposed': image ndarray ('uint8') RGB avec sa segmentation,<br>
'Label': nom de l'image / classe de segmentation,<br>
'Image': image originale ndarray ('uint8') RGB,<br>
'Segmentation': image ndarray ('uint8') RGB du masque de segmentation}</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def imshowSuperimposed(nomImage: str, rle: str = &#39;&#39;, classe: str = &#39;Fish&#39;, repImage: str = &#39;.&#39;, rleSize: tuple = (1400,2100))-&gt; dict:
    &#34;&#34;&#34;Superposition d&#39;une image RGB et de sa segmentation RLE, colorée par classe  
      
     Paramètre  
     ----------  
     nomImage : nom de l&#39;image à afficher  
     repImage : nom du répertoire vers les images (&#39;.&#39; par défaut)  
     rle : encodage RLE du masque à superposer  
     classe : nom de la classe du masque, parmi {&#39;Fish&#39;, &#39;Flower&#39;, &#39;Gravel&#39;, &#39;Sugar&#39;}  
     rleSize : taille du masque RLE en pixels  
       
     Retour  
     ----------  
     dict : {&#39;Superimposed&#39;: image ndarray (&#39;uint8&#39;) RGB avec sa segmentation,  
             &#39;Label&#39;: nom de l&#39;image / classe de segmentation,  
             &#39;Image&#39;: image originale ndarray (&#39;uint8&#39;) RGB,  
             &#39;Segmentation&#39;: image ndarray (&#39;uint8&#39;) RGB du masque de segmentation}  
    &#34;&#34;&#34;
    
    #Initialisation du dictionnaire des couleurs (sur base de RGB)
    couleurs = {&#39;Fish&#39;:  2, #blue
                &#39;Flower&#39;:0, #red
                &#39;Gravel&#39;:1, #green
                &#39;Sugar&#39;:slice(0,2,1)} #yellow

    #Chargement de l&#39;image demandée
    path = os.path.join(repImage, nomImage)
    img = Image.open(path)

    #Si la taille de l&#39;image est différente de celle du masque,
    #on met l&#39;image à l&#39;échelle du masque
    img = img.resize(size = rleSize[::-1], resample = Image.BILINEAR ).convert(&#39;RGB&#39;)

    #Chargement du masque à partir du codage RLE
    mask = np.zeros(rleSize)
    if rle != &#39;&#39; : mask = rleToMask(rle, shape = rleSize)

    #Coloration du masque
    couleur = couleurs[classe]                            # on récupère la couleur de la classe
    imgMask = np.zeros(rleSize+(3,))                      # initialisation du masque pour 3 channels
    imgMask[:,:,couleur] =  np.dstack([mask,mask,mask])[:,:,couleur] * 255  # modification du masque vers trois channels
    imgMask = Image.fromarray(imgMask.astype(&#39;uint8&#39;))

    #Superposition de l&#39;image et de son masque
    #Images converties en numpy.array pour utiliser la fonction addWeighted d&#39;OpenCV
    #Cette fonction est la plus pratique pour conserver l&#39;alpha de l&#39;image originale à 1
    
    imgOverlay = cv2.addWeighted(np.array(img), 1, np.array(imgMask), 0.5, 0.0)
    
    #Si le code rle fourni était vide, on efface la classe par défaut
    if rle == &#39;&#39;: classe = &#39;&#39;
    
    dico = {&#39;Superimposed&#39; : imgOverlay,
            &#39;Label&#39; : nomImage + &#39; / &#39; + classe,
            &#39;Image&#39; : np.array(img),
            &#39;Segmentation&#39;: np.array(imgMask)}
    
    return dico</code></pre>
</details>
</dd>
<dt id="packages.graphics.list_maskToRle"><code class="name flex">
<span>def <span class="ident">list_maskToRle</span></span>(<span>mask_list: numpy.ndarray, reshape: tuple = None) ‑> [<class 'str'>]</span>
</code></dt>
<dd>
<div class="desc"><p>Encodage d'une liste de masques en codes RLE
</p>
<p>Paramètre
</p>
<hr>
<p>mask_list
: liste des masques a encoder<br>
reshape
: facultatif, taille desiree des masques avant encodage
</p>
<p>Retour
</p>
<hr>
<p>liste de str : liste des codes RLE</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_maskToRle(mask_list:np.ndarray , reshape:tuple = None) -&gt; [str]:
    &#34;&#34;&#34;
    Encodage d&#39;une liste de masques en codes RLE  
  
     Paramètre  
     ----------  
     mask_list   : liste des masques a encoder  
     reshape     : facultatif, taille desiree des masques avant encodage  
  
     Retour  
     ----------  
      liste de str : liste des codes RLE  
    &#34;&#34;&#34; 

    width, height, nb_mask = mask_list.shape
    
    rle_list = []
    
    for i in range(nb_mask):
        mask = mask_list[:, :, i]
        
        if reshape:
            mask = mask.astype(np.float32)
            mask = np_transposition(mask, reshape).astype(np.int64)
        
        rle = maskToRle(mask)
        rle_list.append(rle)
        
    return rle_list</code></pre>
</details>
</dd>
<dt id="packages.graphics.list_rleToMask"><code class="name flex">
<span>def <span class="ident">list_rleToMask</span></span>(<span>rle_list: [<class 'str'>], input_shape: tuple, reshape: tuple = None) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Conversion d'une liste d'encodage RLE en liste de masques
</p>
<p>Paramètre
</p>
<hr>
<p>rle_list
: liste des encodage RLE a convertir<br>
input_shape : taille d'origine des masques<br>
reshape
: facultatif, taille desiree en sortie
</p>
<p>Retour
</p>
<hr>
<p>np.ndarray : liste des masques</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_rleToMask(rle_list:[str], input_shape:tuple, reshape: tuple = None)  -&gt; np.ndarray :
    &#34;&#34;&#34;
    Conversion d&#39;une liste d&#39;encodage RLE en liste de masques  
  
     Paramètre  
     ----------  
     rle_list    : liste des encodage RLE a convertir  
     input_shape : taille d&#39;origine des masques  
     reshape     : facultatif, taille desiree en sortie  
  
     Retour  
     ----------  
      np.ndarray : liste des masques  
    &#34;&#34;&#34;  

    nb_rle = len(rle_list)
    if reshape is None:
        mask_list = np.zeros((*input_shape, nb_rle))
    else:
        mask_list = np.zeros((*reshape, nb_rle))
    
    for i, rle in enumerate(rle_list):
        if type(rle) is str:
            if reshape is None:
                mask_list[:, :, i] = rleToMask(rle, input_shape)
            else:
                mask = rleToMask(rle, input_shape)
                reshaped_mask = np_transposition(mask, reshape)
                mask_list[:, :, i] = reshaped_mask
    
    return mask_list</code></pre>
</details>
</dd>
<dt id="packages.graphics.maskInColor"><code class="name flex">
<span>def <span class="ident">maskInColor</span></span>(<span>image: numpy.ndarray, mask: numpy.ndarray, color: tuple = (0, 0, 255), alpha: float = 0.2) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Superposition d'un masque sur une image
</p>
<p>Parameter
</p>
<hr>
<p>image : image sur laqelle le masque doit etre superpose<br>
mask
: masque a superposer<br>
color : colour du masque<br>
alpha : coefficient d'opacite
</p>
<p>Return
</p>
<hr>
<p>np.array : image resultant de la superposition</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def maskInColor(image : np.ndarray, 
                mask : np.ndarray, 
                color : tuple = (0,0,255), 
                alpha : float=0.2) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Superposition d&#39;un masque sur une image  
  
     Parameter  
     ----------  
     image : image sur laqelle le masque doit etre superpose  
     mask  : masque a superposer  
     color : colour du masque  
     alpha : coefficient d&#39;opacite  
  
     Return  
     ----------  
     np.array : image resultant de la superposition  
    &#34;&#34;&#34;
    
    image = np.array(image)
    H,W,C = image.shape
    mask    = mask.reshape(H,W,1)
    overlay = image.astype(np.float32)
    overlay =  255-(255-overlay)*(1-mask*alpha*color/255 )
    overlay = np.clip(overlay,0,255)
    overlay = overlay.astype(np.uint8)
    return overlay</code></pre>
</details>
</dd>
<dt id="packages.graphics.maskToRle"><code class="name flex">
<span>def <span class="ident">maskToRle</span></span>(<span>mask: numpy.ndarray) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Conversion d'un masque en encodage RLE<br>
La presence d'un pixel dans le masque se materialise par la valeur 1,<br>
autrement la valeur reste a 0
</p>
<p>Paramètre
</p>
<hr>
<p>mask : masque a encoder
</p>
<p>Retour
</p>
<hr>
<p>str : encodage RLE</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def maskToRle(mask: np.ndarray) -&gt; str:
    &#34;&#34;&#34;
    Conversion d&#39;un masque en encodage RLE  
    La presence d&#39;un pixel dans le masque se materialise par la valeur 1,  
    autrement la valeur reste a 0  
  
     Paramètre  
     ----------  
     mask : masque a encoder  
  
     Retour  
     ----------  
     str : encodage RLE  
    &#34;&#34;&#34;

    valeur_pixels = mask.T.flatten()
    valeur_pixels = np.concatenate([[0], valeur_pixels, [0]])
    segment_rle = np.where(valeur_pixels[1:] != valeur_pixels[:-1])[0] + 1
    segment_rle[1::2] -= segment_rle[::2]
    return &#39; &#39;.join(str(x) for x in segment_rle)</code></pre>
</details>
</dd>
<dt id="packages.graphics.np_transposition"><code class="name flex">
<span>def <span class="ident">np_transposition</span></span>(<span>image: numpy.ndarray, input_shape: tuple) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Transposition d'un np array afin d'inverser les dimensions (hauteur, largeur) <br>
vers (largeur, hauteur).<br>
Si les dimensions initiales sont différentes de (height,width), un redimensionnement est effectué.
</p>
<p>Paramètre
</p>
<hr>
<p>image : np array a transposer <br>
input_shape : dimensions de l'image cible
</p>
<p>Retour
</p>
<hr>
<p>np.array : image transposee</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def np_transposition(image: np.ndarray, input_shape: tuple) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Transposition d&#39;un np array afin d&#39;inverser les dimensions (hauteur, largeur)   
    vers (largeur, hauteur).  
    Si les dimensions initiales sont différentes de (height,width), un redimensionnement est effectué.  
  
     Paramètre  
     ----------  
     image : np array a transposer   
     input_shape : dimensions de l&#39;image cible  
  
     Retour  
     ----------  
     np.array : image transposee  
    &#34;&#34;&#34;

    height, width = input_shape
    return cv2.resize(image, (width, height))</code></pre>
</details>
</dd>
<dt id="packages.graphics.rleToMask"><code class="name flex">
<span>def <span class="ident">rleToMask</span></span>(<span>rle: str, shape: tuple = (1400, 2100)) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Conversion d'un codage RLE en masque
</p>
<p>Paramètre
</p>
<hr>
<p>rle
: encodage RLE a convertir <br>
shape : format du masque
</p>
<p>Retour
</p>
<hr>
<p>np.array : masque</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rleToMask(rle: str, shape: tuple  =(1400, 2100)) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Conversion d&#39;un codage RLE en masque  
  
     Paramètre  
     ----------  
     rle   : encodage RLE a convertir   
     shape : format du masque  
  
     Retour  
     ----------  
     np.array : masque  
    &#34;&#34;&#34;

    width, height = shape[:2]
    
    mask= np.zeros( width*height ).astype(np.uint8)
    
    array = np.asarray([int(x) for x in rle.split()])
    starts = array[0::2]
    lengths = array[1::2]

    current_position = 0
    for index, start in enumerate(starts):
        mask[int(start):int(start+lengths[index])] = 1
        current_position += lengths[index]
        
    return mask.reshape(height, width).T</code></pre>
</details>
</dd>
<dt id="packages.graphics.surfaceFromRle"><code class="name flex">
<span>def <span class="ident">surfaceFromRle</span></span>(<span>rle: str) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Determination de la surface (en pixels) converte par le masque correspondage
a l'encodage RLE specifie en parametre
</p>
<h2 id="parametre">Paramètre</h2>
<p>rle : encodage RLE a analyser
</p>
<h2 id="retour">Retour</h2>
<p>int : surface couverte en pixels</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def surfaceFromRle(rle: str) -&gt; int:
    &#34;&#34;&#34;Determination de la surface (en pixels) converte par le masque correspondage 
       a l&#39;encodage RLE specifie en parametre  
  
     Paramètre  
     ----------  
     rle : encodage RLE a analyser  
  
     Retour  
     ----------  
     int : surface couverte en pixels  
    &#34;&#34;&#34;  
    
    
    #Initialisation de la surface
    surface = 0
    
    rleNumbers = [int(numstring) for numstring in rle.split(&#39; &#39;)]
    rlePairs = np.array(rleNumbers).reshape(-1,2)

    #Pour chaque pairs, on incrémente la surface par la nouvelle
    #longueur de chaine
    for index,length in rlePairs:
        surface += length
    
    return surface</code></pre>
</details>
</dd>
<dt id="packages.graphics.trace_boundingBox"><code class="name flex">
<span>def <span class="ident">trace_boundingBox</span></span>(<span>image: numpy.ndarray, mask: numpy.ndarray, color: tuple = (0, 0, 255), width: int = 10)</span>
</code></dt>
<dd>
<div class="desc"><p>Draw a bounding box on image</p>
<p>Parameter</p>
<hr>
<p>image : image on which we want to draw the box
mask
: mask to process
color : color we want to use to draw the box edges
width : box edges's width</p>
<p>Return</p>
<hr>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def trace_boundingBox(image : np.ndarray,
                      mask : np.ndarray,
                      color : tuple = (0,0,255),
                      width : int = 10):
    &#34;&#34;&#34;
    Draw a bounding box on image

     Parameter
     ----------
     image : image on which we want to draw the box 
     mask  : mask to process
     color : color we want to use to draw the box edges
     width : box edges&#39;s width

     Return
     ----------
     None
    &#34;&#34;&#34;
    
    lbl = label(mask)
    props = regionprops(lbl)
    for prop in props:
        coin1 = (prop.bbox[3], prop.bbox[2])
        coin2 = (prop.bbox[1], prop.bbox[0])
        cv2.rectangle(image, coin2, coin1, color, width)
    return None</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="packages" href="index.html">packages</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="packages.graphics.cloudInColor" href="#packages.graphics.cloudInColor">cloudInColor</a></code></li>
<li><code><a title="packages.graphics.imshowSuperimposed" href="#packages.graphics.imshowSuperimposed">imshowSuperimposed</a></code></li>
<li><code><a title="packages.graphics.list_maskToRle" href="#packages.graphics.list_maskToRle">list_maskToRle</a></code></li>
<li><code><a title="packages.graphics.list_rleToMask" href="#packages.graphics.list_rleToMask">list_rleToMask</a></code></li>
<li><code><a title="packages.graphics.maskInColor" href="#packages.graphics.maskInColor">maskInColor</a></code></li>
<li><code><a title="packages.graphics.maskToRle" href="#packages.graphics.maskToRle">maskToRle</a></code></li>
<li><code><a title="packages.graphics.np_transposition" href="#packages.graphics.np_transposition">np_transposition</a></code></li>
<li><code><a title="packages.graphics.rleToMask" href="#packages.graphics.rleToMask">rleToMask</a></code></li>
<li><code><a title="packages.graphics.surfaceFromRle" href="#packages.graphics.surfaceFromRle">surfaceFromRle</a></code></li>
<li><code><a title="packages.graphics.trace_boundingBox" href="#packages.graphics.trace_boundingBox">trace_boundingBox</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>